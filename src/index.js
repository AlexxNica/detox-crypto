// Generated by LiveScript 1.5.0
/**
 * @package   Detox crypto
 * @author    Nazar Mokrynskyi <nazar@mokrynskyi.com>
 * @copyright Copyright (c) 2017, Nazar Mokrynskyi
 * @license   MIT License, see license.txt
 */
(function(){
  var randombytes;
  if (typeof exports === 'object') {
    randombytes = require('crypto').randomBytes;
  } else {
    randombytes = function(size){
      var array;
      array = new Uint8Array(size);
      crypto.getRandomValues(array);
      return array;
    };
  }
  /**
   * Increment nonce from `nonce` argument in place
   *
   * @param {!Uint8Array} nonce
   */
  function increment_nonce(nonce){
    var i$, index, results$ = [];
    for (i$ = nonce.length - 1; i$ >= 0; --i$) {
      index = i$;
      ++nonce[index];
      if (nonce[index] !== 0) {
        break;
      }
    }
    return results$;
  }
  function Crypto(supercop, ed2curve, aez, noiseC){
    /**
     * @param {Uint8Array} seed Random seed will be generated if `null`
     *
     * @return {!Object} Object with keys `public` and `private` that contain `Uint8Array` with public and private keys respectively
     */
    var create_keypairs, convert_public_key;
    create_keypairs = function(seed){
      var keys;
      seed == null && (seed = null);
      if (!seed) {
        seed = supercop.createSeed();
      }
      keys = supercop.createKeyPair(seed);
      return {
        'seed': seed,
        'ed25519': {
          'public': keys.publicKey,
          'private': keys.secretKey
        },
        'x25519': {
          'public': ed2curve.convertPublicKey(keys.publicKey),
          'private': ed2curve.convertSecretKey(keys.secretKey)
        }
      };
    };
    /**
     * @param {!Uint8Array} public_key Ed25519 public key
     *
     * @return {Uint8Array} X25519 public key (or `null` if `public_key` was invalid)
     */
    convert_public_key = function(public_key){
      return ed2curve.convertPublicKey(keys.publicKey);
    };
    /**
     * @param {Uint8Array} key Empty when initialized by initiator and specified on responder side
     *
     * @return {Rewrapper}
     */
    function Rewrapper(key){
      key == null && (key = null);
      if (!(this instanceof Rewrapper)) {
        return new Rewrapper(key);
      }
      if (key === null) {
        key = randombytes(48);
      }
      this._key = key;
      return this._nonce = new Uint8Array(12);
    }
    Rewrapper.prototype = {
      /**
       * @return {!Uint8Array}
       */
      'get_key': function(){
        return this._key;
      }
      /**
       * @param {!Uint8Array} plaintext
       *
       * @return {!Uint8Array} Ciphertext
       */,
      'wrap': function(data){
        increment_nonce(this._nonce);
        return aez.encrypt(plaintext, new Uint8Array, this._nonce, this._key, 0);
      }
      /**
       * @param {!Uint8Array} ciphertext
       *
       * @return {!Uint8Array} Plaintext
       */,
      'unwrap': function(ciphertext){
        increment_nonce(this._nonce);
        return aez.decrypt(ciphertext, new Uint8Array, this._nonce, this._key, 0);
      }
    };
    Object.defineProperty(Rewrapper.prototype, 'constructor', {
      enumerable: false,
      value: Rewrapper
    });
    return {
      'ready': Promise.all([supercop.ready, aez.ready, noiseC.ready]).then(function(){}),
      'create_keypairs': create_keypairs,
      'convert_public_key': convert_public_key,
      'Rewrapper': Rewrapper
    };
  }
  if (typeof define === 'function' && define.amd) {
    define(['supercop.wasm', 'ed2curve-js', 'aez.wasm', 'noise-c.wasm'], Crypto);
  } else if (typeof exports === 'object') {
    module.exports = Crypto(require('supercop.wasm'), require('ed2curve-js'), require('aez.wasm'), require('noise-c.wasm'));
  } else {
    this['async_eventer'] = Crypto(this['supercop_wasm'], this['ed2curve'], this['aez_wasm'], this['noise_c_wasm']);
  }
}).call(this);
